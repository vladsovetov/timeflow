/**
 * Generated by orval v7.20.0 üç∫
 * Do not edit manually.
 * Timeflow API
 * API for the Timeflow application
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateTimerCategoryRequest,
  CreateTimerRequest,
  CreateTimerSessionRequest,
  ErrorResponse,
  GetApiV1ExampleDb200,
  GetApiV1TimersParams,
  GetApiV1TimersIdStatsParams,
  MeResponse,
  PostApiV1TimerCategories201,
  ReorderTimersRequest,
  TimerCategoryListResponse,
  TimerListResponse,
  TimerResponse,
  TimerSessionListResponse,
  TimerSessionResponse,
  TimerStatsResponse,
  UpdateProfileRequest,
  UpdateTimerRequest,
  UpdateTimerSessionRequest
} from './models';

import { customFetch } from './customFetch';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Returns the authenticated user's profile information
 * @summary Get current user
 */
export type getApiV1MeResponse200 = {
  data: MeResponse
  status: 200
}

export type getApiV1MeResponse401 = {
  data: ErrorResponse
  status: 401
}

export type getApiV1MeResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type getApiV1MeResponseSuccess = (getApiV1MeResponse200) & {
  headers: Headers;
};
export type getApiV1MeResponseError = (getApiV1MeResponse401 | getApiV1MeResponse404) & {
  headers: Headers;
};

export type getApiV1MeResponse = (getApiV1MeResponseSuccess | getApiV1MeResponseError)

export const getGetApiV1MeUrl = () => {


  

  return `/api/v1/me`
}

export const getApiV1Me = async ( options?: RequestInit): Promise<getApiV1MeResponse> => {
  
  return customFetch<getApiV1MeResponse>(getGetApiV1MeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiV1MeQueryKey = () => {
    return [
    `/api/v1/me`
    ] as const;
    }

    
export const getGetApiV1MeQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1Me>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Me>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1MeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1Me>>> = ({ signal }) => getApiV1Me({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1Me>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1MeQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1Me>>>
export type GetApiV1MeQueryError = ErrorResponse


export function useGetApiV1Me<TData = Awaited<ReturnType<typeof getApiV1Me>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Me>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1Me>>,
          TError,
          Awaited<ReturnType<typeof getApiV1Me>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1Me<TData = Awaited<ReturnType<typeof getApiV1Me>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Me>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1Me>>,
          TError,
          Awaited<ReturnType<typeof getApiV1Me>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1Me<TData = Awaited<ReturnType<typeof getApiV1Me>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Me>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user
 */

export function useGetApiV1Me<TData = Awaited<ReturnType<typeof getApiV1Me>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Me>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1MeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update the authenticated user's profile information
 * @summary Update current user profile
 */
export type patchApiV1MeResponse200 = {
  data: MeResponse
  status: 200
}

export type patchApiV1MeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type patchApiV1MeResponse401 = {
  data: ErrorResponse
  status: 401
}

export type patchApiV1MeResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type patchApiV1MeResponseSuccess = (patchApiV1MeResponse200) & {
  headers: Headers;
};
export type patchApiV1MeResponseError = (patchApiV1MeResponse400 | patchApiV1MeResponse401 | patchApiV1MeResponse404) & {
  headers: Headers;
};

export type patchApiV1MeResponse = (patchApiV1MeResponseSuccess | patchApiV1MeResponseError)

export const getPatchApiV1MeUrl = () => {


  

  return `/api/v1/me`
}

export const patchApiV1Me = async (updateProfileRequest: UpdateProfileRequest, options?: RequestInit): Promise<patchApiV1MeResponse> => {
  
  return customFetch<patchApiV1MeResponse>(getPatchApiV1MeUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateProfileRequest,)
  }
);}




export const getPatchApiV1MeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1Me>>, TError,{data: UpdateProfileRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiV1Me>>, TError,{data: UpdateProfileRequest}, TContext> => {

const mutationKey = ['patchApiV1Me'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiV1Me>>, {data: UpdateProfileRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchApiV1Me(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiV1MeMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiV1Me>>>
    export type PatchApiV1MeMutationBody = UpdateProfileRequest
    export type PatchApiV1MeMutationError = ErrorResponse

    /**
 * @summary Update current user profile
 */
export const usePatchApiV1Me = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1Me>>, TError,{data: UpdateProfileRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiV1Me>>,
        TError,
        {data: UpdateProfileRequest},
        TContext
      > => {

      const mutationOptions = getPatchApiV1MeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List system categories (Useful, Important, Procrastination) and user's custom categories
 * @summary List timer categories
 */
export type getApiV1TimerCategoriesResponse200 = {
  data: TimerCategoryListResponse
  status: 200
}

export type getApiV1TimerCategoriesResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type getApiV1TimerCategoriesResponseSuccess = (getApiV1TimerCategoriesResponse200) & {
  headers: Headers;
};
export type getApiV1TimerCategoriesResponseError = (getApiV1TimerCategoriesResponse401) & {
  headers: Headers;
};

export type getApiV1TimerCategoriesResponse = (getApiV1TimerCategoriesResponseSuccess | getApiV1TimerCategoriesResponseError)

export const getGetApiV1TimerCategoriesUrl = () => {


  

  return `/api/v1/timer-categories`
}

export const getApiV1TimerCategories = async ( options?: RequestInit): Promise<getApiV1TimerCategoriesResponse> => {
  
  return customFetch<getApiV1TimerCategoriesResponse>(getGetApiV1TimerCategoriesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiV1TimerCategoriesQueryKey = () => {
    return [
    `/api/v1/timer-categories`
    ] as const;
    }

    
export const getGetApiV1TimerCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1TimerCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1TimerCategories>>> = ({ signal }) => getApiV1TimerCategories({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1TimerCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1TimerCategories>>>
export type GetApiV1TimerCategoriesQueryError = ErrorResponse


export function useGetApiV1TimerCategories<TData = Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimerCategories>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimerCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimerCategories<TData = Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimerCategories>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimerCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimerCategories<TData = Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List timer categories
 */

export function useGetApiV1TimerCategories<TData = Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerCategories>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1TimerCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a custom timer category for the current user
 * @summary Create custom timer category
 */
export type postApiV1TimerCategoriesResponse201 = {
  data: PostApiV1TimerCategories201
  status: 201
}

export type postApiV1TimerCategoriesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postApiV1TimerCategoriesResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type postApiV1TimerCategoriesResponseSuccess = (postApiV1TimerCategoriesResponse201) & {
  headers: Headers;
};
export type postApiV1TimerCategoriesResponseError = (postApiV1TimerCategoriesResponse400 | postApiV1TimerCategoriesResponse401) & {
  headers: Headers;
};

export type postApiV1TimerCategoriesResponse = (postApiV1TimerCategoriesResponseSuccess | postApiV1TimerCategoriesResponseError)

export const getPostApiV1TimerCategoriesUrl = () => {


  

  return `/api/v1/timer-categories`
}

export const postApiV1TimerCategories = async (createTimerCategoryRequest: CreateTimerCategoryRequest, options?: RequestInit): Promise<postApiV1TimerCategoriesResponse> => {
  
  return customFetch<postApiV1TimerCategoriesResponse>(getPostApiV1TimerCategoriesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTimerCategoryRequest,)
  }
);}




export const getPostApiV1TimerCategoriesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1TimerCategories>>, TError,{data: CreateTimerCategoryRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1TimerCategories>>, TError,{data: CreateTimerCategoryRequest}, TContext> => {

const mutationKey = ['postApiV1TimerCategories'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1TimerCategories>>, {data: CreateTimerCategoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiV1TimerCategories(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1TimerCategoriesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1TimerCategories>>>
    export type PostApiV1TimerCategoriesMutationBody = CreateTimerCategoryRequest
    export type PostApiV1TimerCategoriesMutationError = ErrorResponse

    /**
 * @summary Create custom timer category
 */
export const usePostApiV1TimerCategories = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1TimerCategories>>, TError,{data: CreateTimerCategoryRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1TimerCategories>>,
        TError,
        {data: CreateTimerCategoryRequest},
        TContext
      > => {

      const mutationOptions = getPostApiV1TimerCategoriesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns example database data
 * @summary Get example database data
 */
export type getApiV1ExampleDbResponse200 = {
  data: GetApiV1ExampleDb200
  status: 200
}
    
export type getApiV1ExampleDbResponseSuccess = (getApiV1ExampleDbResponse200) & {
  headers: Headers;
};
;

export type getApiV1ExampleDbResponse = (getApiV1ExampleDbResponseSuccess)

export const getGetApiV1ExampleDbUrl = () => {


  

  return `/api/v1/example-db`
}

export const getApiV1ExampleDb = async ( options?: RequestInit): Promise<getApiV1ExampleDbResponse> => {
  
  return customFetch<getApiV1ExampleDbResponse>(getGetApiV1ExampleDbUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiV1ExampleDbQueryKey = () => {
    return [
    `/api/v1/example-db`
    ] as const;
    }

    
export const getGetApiV1ExampleDbQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1ExampleDbQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1ExampleDb>>> = ({ signal }) => getApiV1ExampleDb({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1ExampleDbQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1ExampleDb>>>
export type GetApiV1ExampleDbQueryError = unknown


export function useGetApiV1ExampleDb<TData = Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1ExampleDb>>,
          TError,
          Awaited<ReturnType<typeof getApiV1ExampleDb>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1ExampleDb<TData = Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1ExampleDb>>,
          TError,
          Awaited<ReturnType<typeof getApiV1ExampleDb>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1ExampleDb<TData = Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get example database data
 */

export function useGetApiV1ExampleDb<TData = Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1ExampleDb>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1ExampleDbQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * List current user's timers (non-deleted)
 * @summary List timers
 */
export type getApiV1TimersResponse200 = {
  data: TimerListResponse
  status: 200
}

export type getApiV1TimersResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type getApiV1TimersResponseSuccess = (getApiV1TimersResponse200) & {
  headers: Headers;
};
export type getApiV1TimersResponseError = (getApiV1TimersResponse401) & {
  headers: Headers;
};

export type getApiV1TimersResponse = (getApiV1TimersResponseSuccess | getApiV1TimersResponseError)

export const getGetApiV1TimersUrl = (params?: GetApiV1TimersParams) => {
  const normalizedParams = new URLSearchParams();
  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });
  const stringifiedParams = normalizedParams.toString();
  return stringifiedParams.length > 0
    ? `/api/v1/timers?${stringifiedParams}`
    : `/api/v1/timers`;
};

export const getApiV1Timers = async (
  params?: GetApiV1TimersParams,
  options?: RequestInit
): Promise<getApiV1TimersResponse> => {
  return customFetch<getApiV1TimersResponse>(getGetApiV1TimersUrl(params), {
    ...options,
    method: "GET",
  });
};





export const getGetApiV1TimersQueryKey = (params?: GetApiV1TimersParams) => {
  return ["/api/v1/timers", ...(params ? [params] : [])] as const;
};

export const getGetApiV1TimersQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiV1Timers>>,
  TError = ErrorResponse
>(
  params?: GetApiV1TimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiV1Timers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};
  const queryKey = queryOptions?.queryKey ?? getGetApiV1TimersQueryKey(params);
  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiV1Timers>>
  > = ({ signal }) => getApiV1Timers(params, { signal, ...requestOptions });

      

      

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiV1Timers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApiV1TimersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiV1Timers>>
>;
export type GetApiV1TimersQueryError = ErrorResponse;

export function useGetApiV1Timers<
  TData = Awaited<ReturnType<typeof getApiV1Timers>>,
  TError = ErrorResponse
>(
  params?: GetApiV1TimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiV1Timers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiV1TimersQueryOptions(params, options);
  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };
  query.queryKey = queryOptions.queryKey;
  return query;
}





/**
 * Create a new timer for the current user
 * @summary Create timer
 */
export type postApiV1TimersResponse201 = {
  data: TimerResponse
  status: 201
}

export type postApiV1TimersResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postApiV1TimersResponse401 = {
  data: ErrorResponse
  status: 401
}

export type postApiV1TimersResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type postApiV1TimersResponseSuccess = (postApiV1TimersResponse201) & {
  headers: Headers;
};
export type postApiV1TimersResponseError = (postApiV1TimersResponse400 | postApiV1TimersResponse401 | postApiV1TimersResponse409) & {
  headers: Headers;
};

export type postApiV1TimersResponse = (postApiV1TimersResponseSuccess | postApiV1TimersResponseError)

export const getPostApiV1TimersUrl = () => {


  

  return `/api/v1/timers`
}

export const postApiV1Timers = async (createTimerRequest: CreateTimerRequest, options?: RequestInit): Promise<postApiV1TimersResponse> => {
  
  return customFetch<postApiV1TimersResponse>(getPostApiV1TimersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTimerRequest,)
  }
);}




export const getPostApiV1TimersMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1Timers>>, TError,{data: CreateTimerRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1Timers>>, TError,{data: CreateTimerRequest}, TContext> => {

const mutationKey = ['postApiV1Timers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1Timers>>, {data: CreateTimerRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiV1Timers(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1TimersMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1Timers>>>
    export type PostApiV1TimersMutationBody = CreateTimerRequest
    export type PostApiV1TimersMutationError = ErrorResponse

    /**
 * @summary Create timer
 */
export const usePostApiV1Timers = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1Timers>>, TError,{data: CreateTimerRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1Timers>>,
        TError,
        {data: CreateTimerRequest},
        TContext
      > => {

      const mutationOptions = getPostApiV1TimersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get a single timer by id
 * @summary Get timer
 */
export type getApiV1TimersIdResponse200 = {
  data: TimerResponse
  status: 200
}

export type getApiV1TimersIdResponse401 = {
  data: ErrorResponse
  status: 401
}

export type getApiV1TimersIdResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type getApiV1TimersIdResponseSuccess = (getApiV1TimersIdResponse200) & {
  headers: Headers;
};
export type getApiV1TimersIdResponseError = (getApiV1TimersIdResponse401 | getApiV1TimersIdResponse404) & {
  headers: Headers;
};

export type getApiV1TimersIdResponse = (getApiV1TimersIdResponseSuccess | getApiV1TimersIdResponseError)

export const getGetApiV1TimersIdUrl = (id: string,) => {


  

  return `/api/v1/timers/${id}`
}

export const getApiV1TimersId = async (id: string, options?: RequestInit): Promise<getApiV1TimersIdResponse> => {
  
  return customFetch<getApiV1TimersIdResponse>(getGetApiV1TimersIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiV1TimersIdQueryKey = (id?: string,) => {
    return [
    `/api/v1/timers/${id}`
    ] as const;
    }

    
export const getGetApiV1TimersIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1TimersId>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1TimersIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1TimersId>>> = ({ signal }) => getApiV1TimersId(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1TimersIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1TimersId>>>
export type GetApiV1TimersIdQueryError = ErrorResponse


export function useGetApiV1TimersId<TData = Awaited<ReturnType<typeof getApiV1TimersId>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimersId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimersId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimersId<TData = Awaited<ReturnType<typeof getApiV1TimersId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimersId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimersId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimersId<TData = Awaited<ReturnType<typeof getApiV1TimersId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get timer
 */

export function useGetApiV1TimersId<TData = Awaited<ReturnType<typeof getApiV1TimersId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1TimersIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing timer
 * @summary Update timer
 */
export type patchApiV1TimersIdResponse200 = {
  data: TimerResponse
  status: 200
}

export type patchApiV1TimersIdResponse400 = {
  data: ErrorResponse
  status: 400
}

export type patchApiV1TimersIdResponse401 = {
  data: ErrorResponse
  status: 401
}

export type patchApiV1TimersIdResponse404 = {
  data: ErrorResponse
  status: 404
}

export type patchApiV1TimersIdResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type patchApiV1TimersIdResponseSuccess = (patchApiV1TimersIdResponse200) & {
  headers: Headers;
};
export type patchApiV1TimersIdResponseError = (patchApiV1TimersIdResponse400 | patchApiV1TimersIdResponse401 | patchApiV1TimersIdResponse404 | patchApiV1TimersIdResponse409) & {
  headers: Headers;
};

export type patchApiV1TimersIdResponse = (patchApiV1TimersIdResponseSuccess | patchApiV1TimersIdResponseError)

export const getPatchApiV1TimersIdUrl = (id: string,) => {


  

  return `/api/v1/timers/${id}`
}

export const patchApiV1TimersId = async (id: string,
    updateTimerRequest: UpdateTimerRequest, options?: RequestInit): Promise<patchApiV1TimersIdResponse> => {
  
  return customFetch<patchApiV1TimersIdResponse>(getPatchApiV1TimersIdUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateTimerRequest,)
  }
);}




export const getPatchApiV1TimersIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimersId>>, TError,{id: string;data: UpdateTimerRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimersId>>, TError,{id: string;data: UpdateTimerRequest}, TContext> => {

const mutationKey = ['patchApiV1TimersId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiV1TimersId>>, {id: string;data: UpdateTimerRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  patchApiV1TimersId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiV1TimersIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiV1TimersId>>>
    export type PatchApiV1TimersIdMutationBody = UpdateTimerRequest
    export type PatchApiV1TimersIdMutationError = ErrorResponse

    /**
 * @summary Update timer
 */
export const usePatchApiV1TimersId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimersId>>, TError,{id: string;data: UpdateTimerRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiV1TimersId>>,
        TError,
        {id: string;data: UpdateTimerRequest},
        TContext
      > => {

      const mutationOptions = getPatchApiV1TimersIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Soft-delete a timer
 * @summary Delete timer
 */
export type deleteApiV1TimersIdResponse204 = {
  data: void
  status: 204
}

export type deleteApiV1TimersIdResponse401 = {
  data: ErrorResponse
  status: 401
}

export type deleteApiV1TimersIdResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type deleteApiV1TimersIdResponseSuccess = (deleteApiV1TimersIdResponse204) & {
  headers: Headers;
};
export type deleteApiV1TimersIdResponseError = (deleteApiV1TimersIdResponse401 | deleteApiV1TimersIdResponse404) & {
  headers: Headers;
};

export type deleteApiV1TimersIdResponse = (deleteApiV1TimersIdResponseSuccess | deleteApiV1TimersIdResponseError)

export const getDeleteApiV1TimersIdUrl = (id: string,) => {


  

  return `/api/v1/timers/${id}`
}

export const deleteApiV1TimersId = async (id: string, options?: RequestInit): Promise<deleteApiV1TimersIdResponse> => {
  
  return customFetch<deleteApiV1TimersIdResponse>(getDeleteApiV1TimersIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteApiV1TimersIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1TimersId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1TimersId>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteApiV1TimersId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiV1TimersId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteApiV1TimersId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiV1TimersIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiV1TimersId>>>
    
    export type DeleteApiV1TimersIdMutationError = ErrorResponse

    /**
 * @summary Delete timer
 */
export const useDeleteApiV1TimersId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1TimersId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiV1TimersId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteApiV1TimersIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update sort_order for all timers in a single request. Order of timer_ids array = sort_order (index 0 ‚Üí 0, index 1 ‚Üí 1, etc.)
 * @summary Reorder timers
 */
export type patchApiV1TimersReorderResponse200 = {
  data: void
  status: 200
}

export type patchApiV1TimersReorderResponse400 = {
  data: ErrorResponse
  status: 400
}

export type patchApiV1TimersReorderResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type patchApiV1TimersReorderResponseSuccess = (patchApiV1TimersReorderResponse200) & {
  headers: Headers;
};
export type patchApiV1TimersReorderResponseError = (patchApiV1TimersReorderResponse400 | patchApiV1TimersReorderResponse401) & {
  headers: Headers;
};

export type patchApiV1TimersReorderResponse = (patchApiV1TimersReorderResponseSuccess | patchApiV1TimersReorderResponseError)

export const getPatchApiV1TimersReorderUrl = () => {


  

  return `/api/v1/timers/reorder`
}

export const patchApiV1TimersReorder = async (reorderTimersRequest: ReorderTimersRequest, options?: RequestInit): Promise<patchApiV1TimersReorderResponse> => {
  
  return customFetch<patchApiV1TimersReorderResponse>(getPatchApiV1TimersReorderUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      reorderTimersRequest,)
  }
);}




export const getPatchApiV1TimersReorderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimersReorder>>, TError,{data: ReorderTimersRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimersReorder>>, TError,{data: ReorderTimersRequest}, TContext> => {

const mutationKey = ['patchApiV1TimersReorder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiV1TimersReorder>>, {data: ReorderTimersRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchApiV1TimersReorder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiV1TimersReorderMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiV1TimersReorder>>>
    export type PatchApiV1TimersReorderMutationBody = ReorderTimersRequest
    export type PatchApiV1TimersReorderMutationError = ErrorResponse

    /**
 * @summary Reorder timers
 */
export const usePatchApiV1TimersReorder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimersReorder>>, TError,{data: ReorderTimersRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiV1TimersReorder>>,
        TError,
        {data: ReorderTimersRequest},
        TContext
      > => {

      const mutationOptions = getPatchApiV1TimersReorderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get total timer session time per day for a timer. Optionally filter by date range using start_date and end_date query parameters (DateOnly format: YYYY-MM-DD).
 * @summary Get timer statistics
 */
export type getApiV1TimersIdStatsResponse200 = {
  data: TimerStatsResponse
  status: 200
}

export type getApiV1TimersIdStatsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getApiV1TimersIdStatsResponse401 = {
  data: ErrorResponse
  status: 401
}

export type getApiV1TimersIdStatsResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type getApiV1TimersIdStatsResponseSuccess = (getApiV1TimersIdStatsResponse200) & {
  headers: Headers;
};
export type getApiV1TimersIdStatsResponseError = (getApiV1TimersIdStatsResponse400 | getApiV1TimersIdStatsResponse401 | getApiV1TimersIdStatsResponse404) & {
  headers: Headers;
};

export type getApiV1TimersIdStatsResponse = (getApiV1TimersIdStatsResponseSuccess | getApiV1TimersIdStatsResponseError)

export const getGetApiV1TimersIdStatsUrl = (id: string,
    params?: GetApiV1TimersIdStatsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/timers/${id}/stats?${stringifiedParams}` : `/api/v1/timers/${id}/stats`
}

export const getApiV1TimersIdStats = async (id: string,
    params?: GetApiV1TimersIdStatsParams, options?: RequestInit): Promise<getApiV1TimersIdStatsResponse> => {
  
  return customFetch<getApiV1TimersIdStatsResponse>(getGetApiV1TimersIdStatsUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiV1TimersIdStatsQueryKey = (id?: string,
    params?: GetApiV1TimersIdStatsParams,) => {
    return [
    `/api/v1/timers/${id}/stats`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiV1TimersIdStatsQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError = ErrorResponse>(id: string,
    params?: GetApiV1TimersIdStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1TimersIdStatsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1TimersIdStats>>> = ({ signal }) => getApiV1TimersIdStats(id,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1TimersIdStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1TimersIdStats>>>
export type GetApiV1TimersIdStatsQueryError = ErrorResponse


export function useGetApiV1TimersIdStats<TData = Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError = ErrorResponse>(
 id: string,
    params: undefined |  GetApiV1TimersIdStatsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimersIdStats>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimersIdStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimersIdStats<TData = Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError = ErrorResponse>(
 id: string,
    params?: GetApiV1TimersIdStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimersIdStats>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimersIdStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimersIdStats<TData = Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError = ErrorResponse>(
 id: string,
    params?: GetApiV1TimersIdStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get timer statistics
 */

export function useGetApiV1TimersIdStats<TData = Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError = ErrorResponse>(
 id: string,
    params?: GetApiV1TimersIdStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimersIdStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1TimersIdStatsQueryOptions(id,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * List current user's timer sessions (non-deleted)
 * @summary List timer sessions
 */
export type getApiV1TimerSessionsResponse200 = {
  data: TimerSessionListResponse
  status: 200
}

export type getApiV1TimerSessionsResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type getApiV1TimerSessionsResponseSuccess = (getApiV1TimerSessionsResponse200) & {
  headers: Headers;
};
export type getApiV1TimerSessionsResponseError = (getApiV1TimerSessionsResponse401) & {
  headers: Headers;
};

export type getApiV1TimerSessionsResponse = (getApiV1TimerSessionsResponseSuccess | getApiV1TimerSessionsResponseError)

export const getGetApiV1TimerSessionsUrl = () => {


  

  return `/api/v1/timer-sessions`
}

export const getApiV1TimerSessions = async ( options?: RequestInit): Promise<getApiV1TimerSessionsResponse> => {
  
  return customFetch<getApiV1TimerSessionsResponse>(getGetApiV1TimerSessionsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiV1TimerSessionsQueryKey = () => {
    return [
    `/api/v1/timer-sessions`
    ] as const;
    }

    
export const getGetApiV1TimerSessionsQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1TimerSessionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1TimerSessions>>> = ({ signal }) => getApiV1TimerSessions({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1TimerSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1TimerSessions>>>
export type GetApiV1TimerSessionsQueryError = ErrorResponse


export function useGetApiV1TimerSessions<TData = Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimerSessions>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimerSessions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimerSessions<TData = Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1TimerSessions>>,
          TError,
          Awaited<ReturnType<typeof getApiV1TimerSessions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1TimerSessions<TData = Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List timer sessions
 */

export function useGetApiV1TimerSessions<TData = Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1TimerSessions>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1TimerSessionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new timer session for the current user
 * @summary Create timer session
 */
export type postApiV1TimerSessionsResponse201 = {
  data: TimerSessionResponse
  status: 201
}

export type postApiV1TimerSessionsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postApiV1TimerSessionsResponse401 = {
  data: ErrorResponse
  status: 401
}

export type postApiV1TimerSessionsResponse404 = {
  data: ErrorResponse
  status: 404
}

export type postApiV1TimerSessionsResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type postApiV1TimerSessionsResponseSuccess = (postApiV1TimerSessionsResponse201) & {
  headers: Headers;
};
export type postApiV1TimerSessionsResponseError = (postApiV1TimerSessionsResponse400 | postApiV1TimerSessionsResponse401 | postApiV1TimerSessionsResponse404 | postApiV1TimerSessionsResponse409) & {
  headers: Headers;
};

export type postApiV1TimerSessionsResponse = (postApiV1TimerSessionsResponseSuccess | postApiV1TimerSessionsResponseError)

export const getPostApiV1TimerSessionsUrl = () => {


  

  return `/api/v1/timer-sessions`
}

export const postApiV1TimerSessions = async (createTimerSessionRequest: CreateTimerSessionRequest, options?: RequestInit): Promise<postApiV1TimerSessionsResponse> => {
  
  return customFetch<postApiV1TimerSessionsResponse>(getPostApiV1TimerSessionsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTimerSessionRequest,)
  }
);}




export const getPostApiV1TimerSessionsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1TimerSessions>>, TError,{data: CreateTimerSessionRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1TimerSessions>>, TError,{data: CreateTimerSessionRequest}, TContext> => {

const mutationKey = ['postApiV1TimerSessions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1TimerSessions>>, {data: CreateTimerSessionRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiV1TimerSessions(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1TimerSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1TimerSessions>>>
    export type PostApiV1TimerSessionsMutationBody = CreateTimerSessionRequest
    export type PostApiV1TimerSessionsMutationError = ErrorResponse

    /**
 * @summary Create timer session
 */
export const usePostApiV1TimerSessions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1TimerSessions>>, TError,{data: CreateTimerSessionRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1TimerSessions>>,
        TError,
        {data: CreateTimerSessionRequest},
        TContext
      > => {

      const mutationOptions = getPostApiV1TimerSessionsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update an existing timer session (e.g. set end time when pausing)
 * @summary Update timer session
 */
export type patchApiV1TimerSessionsIdResponse200 = {
  data: TimerSessionResponse
  status: 200
}

export type patchApiV1TimerSessionsIdResponse400 = {
  data: ErrorResponse
  status: 400
}

export type patchApiV1TimerSessionsIdResponse401 = {
  data: ErrorResponse
  status: 401
}

export type patchApiV1TimerSessionsIdResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type patchApiV1TimerSessionsIdResponseSuccess = (patchApiV1TimerSessionsIdResponse200) & {
  headers: Headers;
};
export type patchApiV1TimerSessionsIdResponseError = (patchApiV1TimerSessionsIdResponse400 | patchApiV1TimerSessionsIdResponse401 | patchApiV1TimerSessionsIdResponse404) & {
  headers: Headers;
};

export type patchApiV1TimerSessionsIdResponse = (patchApiV1TimerSessionsIdResponseSuccess | patchApiV1TimerSessionsIdResponseError)

export const getPatchApiV1TimerSessionsIdUrl = (id: string,) => {


  

  return `/api/v1/timer-sessions/${id}`
}

export const patchApiV1TimerSessionsId = async (id: string,
    updateTimerSessionRequest: UpdateTimerSessionRequest, options?: RequestInit): Promise<patchApiV1TimerSessionsIdResponse> => {
  
  return customFetch<patchApiV1TimerSessionsIdResponse>(getPatchApiV1TimerSessionsIdUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateTimerSessionRequest,)
  }
);}




export const getPatchApiV1TimerSessionsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimerSessionsId>>, TError,{id: string;data: UpdateTimerSessionRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimerSessionsId>>, TError,{id: string;data: UpdateTimerSessionRequest}, TContext> => {

const mutationKey = ['patchApiV1TimerSessionsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiV1TimerSessionsId>>, {id: string;data: UpdateTimerSessionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  patchApiV1TimerSessionsId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiV1TimerSessionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiV1TimerSessionsId>>>
    export type PatchApiV1TimerSessionsIdMutationBody = UpdateTimerSessionRequest
    export type PatchApiV1TimerSessionsIdMutationError = ErrorResponse

    /**
 * @summary Update timer session
 */
export const usePatchApiV1TimerSessionsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1TimerSessionsId>>, TError,{id: string;data: UpdateTimerSessionRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiV1TimerSessionsId>>,
        TError,
        {id: string;data: UpdateTimerSessionRequest},
        TContext
      > => {

      const mutationOptions = getPatchApiV1TimerSessionsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Soft-delete a timer session
 * @summary Delete timer session
 */
export type deleteApiV1TimerSessionsIdResponse204 = {
  data: void
  status: 204
}

export type deleteApiV1TimerSessionsIdResponse401 = {
  data: ErrorResponse
  status: 401
}

export type deleteApiV1TimerSessionsIdResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type deleteApiV1TimerSessionsIdResponseSuccess = (deleteApiV1TimerSessionsIdResponse204) & {
  headers: Headers;
};
export type deleteApiV1TimerSessionsIdResponseError = (deleteApiV1TimerSessionsIdResponse401 | deleteApiV1TimerSessionsIdResponse404) & {
  headers: Headers;
};

export type deleteApiV1TimerSessionsIdResponse = (deleteApiV1TimerSessionsIdResponseSuccess | deleteApiV1TimerSessionsIdResponseError)

export const getDeleteApiV1TimerSessionsIdUrl = (id: string,) => {


  

  return `/api/v1/timer-sessions/${id}`
}

export const deleteApiV1TimerSessionsId = async (id: string, options?: RequestInit): Promise<deleteApiV1TimerSessionsIdResponse> => {
  
  return customFetch<deleteApiV1TimerSessionsIdResponse>(getDeleteApiV1TimerSessionsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteApiV1TimerSessionsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1TimerSessionsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1TimerSessionsId>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteApiV1TimerSessionsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiV1TimerSessionsId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteApiV1TimerSessionsId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiV1TimerSessionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiV1TimerSessionsId>>>
    
    export type DeleteApiV1TimerSessionsIdMutationError = ErrorResponse

    /**
 * @summary Delete timer session
 */
export const useDeleteApiV1TimerSessionsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1TimerSessionsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiV1TimerSessionsId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteApiV1TimerSessionsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
